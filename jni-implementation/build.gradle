import static CompilerOs.*
import static org.gradle.internal.os.OperatingSystem.current

plugins {
  id("dev.welbyseely.gradle-cmake-plugin") version "0.0.5"
  id("maven-publish")
}

def os
if (project.hasProperty("operatingSystem")) {
  os = valueOf(project.findProperty("operatingSystem") as String)
} else {
  os = getHostOS()
}

def compiler
if (project.hasProperty("compiler")) {
  compiler = Compilers.valueOf(project.findProperty("compiler") as String)
} else {
  compiler = os == WINDOWS ? getWindowsCompiler() : getUnixLikeCompiler()
}

def arch
if (project.hasProperty("arch")) {
  arch = Architectures.valueOf(project.findProperty("arch") as String)
} else {
  arch = Architectures.getHostArch()
}

if (!compiler || compiler == Compilers.NONE_FOUND) {
  final errorMessage = "No supported compilers found. Build cannot continue."
  logger.error errorMessage
  throw new GradleScriptException(errorMessage, null)
}

final toolChain = Toolchains.getToolchain(os, getHostOS(), arch, compiler)
if (!toolChain) {
  logger.warn "No toolchain found for architecture=${arch.name()}, hostOs=${getHostOS().name()}, operatingSystem=${os.name()}, compiler=${compiler.name()}"
}

cmake {
  generator = toolChain.generator
  sourceFolder = file("$projectDir/src")
  buildSharedLibs = true
  setDef(['BUILD_LLAMA_CPP'     : 'ON',
          'BUILD_SHARED_LIBS'   : 'ON',
          'LLAMA_BUILD_EXAMPLES': 'OFF',
          'CMAKE_TOOLCHAIN_FILE': projectDir as String + "/src/" + toolChain.file
  ])
  if (toolChain.customDefs && !toolChain.customDefs.isEmpty()) {
    toolChain.customDefs.entrySet()
      .forEach { entry ->
        getDef().put(entry.getKey(), entry.getValue())
      }
  }
  buildConfig = 'Release'
  buildClean = true
}

def getLibExtension(final CompilerOs operatingSystem) {
  switch(operatingSystem) {
    case WINDOWS:
      return 'dll'
    case MACOS:
      return 'dylib'
    case LINUX:
    case OTHER:
    default:
      return 'so'
  }
}
def getLibPrefix(final CompilerOs operatingSystem) {
  if (operatingSytstem != WINDOWS) {
    return 'lib'
  }
  return ''
}

static def getOSAndArch() {
  def os = current()
  def arch = System.getProperty('os.arch')
  return "${os.getFamilyName()}_${arch}"
}

publishing {
  publications {
    nativeLib(MavenPublication) {}
  }
  repositories {
    mavenLocal()
  }
}

task prepareDllForPublish {
  dependsOn build
  doLast {
    publishing.publications.nativeLib.artifact(
      file("$buildDir/cmake/jni-implementation/release/${getLibPrefix(os)}jni-implementation.${getLibExtension(os)}")) {
      classifier = getOSAndArch()
    }
  }
}

tasks.withType(PublishToMavenLocal) {
  dependsOn prepareDllForPublish
}

static def getWindowsCompiler() {
  if (Compilers.MSVC.isPresent()) {
    return Compilers.MSVC
  } else if (Compilers.MINGW.isPresent()) {
    return Compilers.MINGW
  } else {
    return Compilers.NONE_FOUND
  }
}

static def getUnixLikeCompiler() {
  if (Compilers.GCC.isPresent()) {
    return Compilers.GCC
  } else if (Compilers.CLANG.isPresent()) {
    return Compilers.CLANG
  } else {
    return Compilers.NONE_FOUND
  }
}

static def getHostOS() {
  current().isWindows() ? WINDOWS :
    current().isLinux() ? LINUX :
      current().isMacOsX() ? MACOS : OTHER
}

